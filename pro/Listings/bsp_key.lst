C51 COMPILER V9.59.0.0   BSP_KEY                                                           04/16/2019 15:00:56 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE BSP_KEY
OBJECT MODULE PLACED IN .\Objects\bsp_key.obj
COMPILER INVOKED BY: E:\MDK\C51\BIN\C51.EXE ..\bsp\bsp_key.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\bsp;..\lib;..\user;..\Ti
                    -meOut) DEBUG OBJECTEXTEND PRINT(.\Listings\bsp_key.lst) TABS(7) OBJECT(.\Objects\bsp_key.obj)

line level    source

   1          #include "bsp_key.h"
   2          #include "TimeOut.h"
   3          #include "key_port.h"
   4          #include "bsp_pwm.h"
   5          #include "bsp_lock.h"
   6          #include "bsp_motro.h"
   7          
   8          
   9          
  10          
  11          typedef enum {
  12              KEY_STATE_IDLE,
  13              KEY_STATE_JITTER,
  14              KEY_STATE_PRESS_DOWN,
  15              KEY_STATE_CP
  16          } KEY_STATE;
  17          
  18          unsigned char SendBackData;
  19          unsigned long get_key_data;
  20          
  21          unsigned char LedOnlyOneInputFlag;
  22          //KEY_MSG_STATUS KeyMsgStatus;
  23          
  24          static TIMEOUT_PARA Key_Scan_Timer,Key_Wait_Timer;
  25          static KEY_STATE     KeyState;
  26          static t_KEY_MSG Key_Msg;
  27          static unsigned char PreKeyIndex = MSG_INVALID;
  28          
  29          extern unsigned char Lock_Flag;
  30          extern unsigned char Pwm_Level;
  31          
  32          static void (*GetValueCb)(unsigned char);
  33          
  34          
  35          /**
  36                 @function: °´¼üÊÂ¼þ£¬¸ü¶à°´¼üÊ±£¬¶ÔÓ¦Ôö¼Ó°´¼ü°´¼ü
  37                 
  38          */
  39          static xdata unsigned char KeyEvent[11][5]=
  40          {
  41                 //°´¼ü¿ªÊ¼(°´ÏÂ)                   ¶Ì°´                                                    ³¤°´                               ³¤°´±£³Ö                                         ³¤°´ËÉ¿ª
  42                 {MSG_KEY_NONE,                                   MSG_KEY_NONE,                                    MSG_KEY_NONE,               MSG_KEY_NONE,                                    MSG_KEY_NONE},                     // ¿Õ£¬ÎÞÓÃ
  43                 {MSG_KEY1_PRESS,                          MSG_KEY1_SHORT_PRESS,                            MSG_KEY1_LONGPRESS,  MSG_KEY1_LONGPRESS_HD,                           MSG_KEY1_LONGP
             -RESS_RE},              // key1
  44                 {MSG_KEY2_PRESS,                          MSG_KEY2_SHORT_PRESS,                            MSG_KEY2_LONGPRESS,  MSG_KEY2_LONGPRESS_HD,                           MSG_KEY2_LONGP
             -RESS_RE},              // key2
  45                 {MSG_KEY3_PRESS,                          MSG_KEY3_SHORT_PRESS,                            MSG_KEY3_LONGPRESS,  MSG_KEY3_LONGPRESS_HD,                           MSG_KEY3_LON
             -GPRESS_RE},       // key3       
  46                 {MSG_KEY4_PRESS,                          MSG_KEY4_SHORT_PRESS,                            MSG_KEY4_LONGPRESS,  MSG_KEY4_LONGPRESS_HD,                           MSG_KEY4_LON
             -GPRESS_RE},       // key4       
  47                 {MSG_KEY5_PRESS,                          MSG_KEY5_SHORT_PRESS,                            MSG_KEY5_LONGPRESS,  MSG_KEY5_LONGPRESS_HD,                           MSG_KEY5_LON
             -GPRESS_RE},       // key5
  48                 {MSG_KEY6_PRESS,                          MSG_KEY6_SHORT_PRESS,                            MSG_KEY6_LONGPRESS,  MSG_KEY6_LONGPRESS_HD,                           MSG_KEY6_LON
             -GPRESS_RE},       // key6
C51 COMPILER V9.59.0.0   BSP_KEY                                                           04/16/2019 15:00:56 PAGE 2   

  49                 {MSG_KEY7_PRESS,                          MSG_KEY7_SHORT_PRESS,                            MSG_KEY7_LONGPRESS,  MSG_KEY7_LONGPRESS_HD,                           MSG_KEY7_LON
             -GPRESS_RE},       // key7
  50                 {MSG_KEY8_PRESS,                          MSG_KEY8_SHORT_PRESS,                            MSG_KEY8_LONGPRESS,  MSG_KEY8_LONGPRESS_HD,                           MSG_KE
             -Y8_LONGPRESS_RE},    // key8
  51                 {MSG_KEY9_PRESS,                          MSG_KEY9_SHORT_PRESS,                            MSG_KEY9_LONGPRESS,   MSG_KEY9_LONGPRESS_HD,                   MSG_KEY
             -9_LONGPRESS_RE},     // key9
  52                 {MSG_KEY10_PRESS,                         MSG_KEY10_SHORT_PRESS,                           MSG_KEY10_LONGPRESS,  MSG_KEY10_LONGPRESS_HD,                  MSG
             -_KEY10_LONGPRESS_RE}, // key7
  53          };
  54          
  55          /**
  56                 @function:    »ñÈ¡°´¼üË÷ÒýÖµ
  57                 ¸ù¾Ý°´¼üµÄ¸öÊý£¬ÐèÒª×öÏàÓ¦µÄÐÞ¸Ä
  58          */
  59          static unsigned char GetKeyIndex(void)
  60          {
  61   1             extern unsigned long Key_Port_Read(unsigned char num);
  62   1             unsigned char value = 0,cnt = 0;
  63   1             if(Key_Port_Read(1))
  64   1                    cnt ++,value = 1;
  65   1             if(Key_Port_Read(2))
  66   1                    cnt ++,value = 2;
  67   1             if(Key_Port_Read(3))
  68   1                    cnt ++,value = 3;
  69   1             if(Key_Port_Read(4))
  70   1                    cnt ++,value = 4;
  71   1             if(Key_Port_Read(5))
  72   1                    cnt ++,value = 5;
  73   1             if(Key_Port_Read(6))
  74   1                    cnt ++,value = 6;
  75   1             if(Key_Port_Read(7))
  76   1                    cnt ++,value = 7;
  77   1             if(Key_Port_Read(8))
  78   1                    cnt ++,value = 8;
  79   1             if(Key_Port_Read(9))
  80   1                    cnt ++,value = 9;
  81   1             if(Key_Port_Read(10))
  82   1                    cnt ++,value = 10;
  83   1             if(cnt > 1)
  84   1                    value = MSG_INVALID;
  85   1             return value; 
  86   1      }
  87          
  88          
  89          void  Key_Init(void)
  90          {
  91   1             TouchKeyInit(); // ´¥¿Ø°´¼ü³õÊ¼»¯
  92   1             KeyState=KEY_STATE_IDLE;
  93   1             TimeOut_Record(&Key_Scan_Timer,0);
  94   1      }
  95          
  96          void Key_Function(unsigned char GetValue)
  97          {
  98   1             static unsigned char TempCnts,LockCnts,LockFlag;
  99   1             if(GetValue == MSG_KEY_NONE)
 100   1             {
 101   2                    if((SendBackData == Led1_OpenData)||(SendBackData == Led1_CloseData))
 102   2                    {
 103   3                           LedOnlyOneInputFlag = 0;
 104   3                    }
 105   2                    else
 106   2                    {
C51 COMPILER V9.59.0.0   BSP_KEY                                                           04/16/2019 15:00:56 PAGE 3   

 107   3                           if(SendBackData != NoData)
 108   3                           {
 109   4                                  SendBackData = NoData;
 110   4                           }
 111   3                    }
 112   2                    LockFlag = 0;
 113   2             }
 114   1             else if((GetValue == MSG_KEY1_SHORT_PRESS)&&(!Lock_Flag))
 115   1             {
 116   2                    #if 0
                            if((SendBackData != Led1_OpenData)||(SendBackData != Led1_CloseData))
                            {
                                   ++ TempCnts;
                                   if(TempCnts & 0x01)
                                   {
                                          SendBackData = Led1_OpenData;
                                          Pwm100_Level();
                                   }
                                   else
                                   {
                                          SendBackData = Led1_CloseData;
                                          Pwm15_Level();
                                   }
                            }
                            #else
 132   2                    if(!LedOnlyOneInputFlag)
 133   2                    {
 134   3                           LedOnlyOneInputFlag = 1;
 135   3                           ++ TempCnts;
 136   3                           if(TempCnts & 0x01)
 137   3                           {
 138   4                                  SendBackData = Led1_OpenData;
 139   4                                  Pwm100_Level();
 140   4                           }
 141   3                           else
 142   3                           {
 143   4                                  SendBackData = Led1_CloseData;
 144   4                                  Pwm15_Level();
 145   4                           }
 146   3                     }
 147   2                    #endif
 148   2             }
 149   1             else if((GetValue == MSG_KEY2_SHORT_PRESS)&&(!Lock_Flag))
 150   1             {
 151   2                    Motro_Handle();
 152   2             }
 153   1             else if((GetValue == MSG_KEY3_PRESS)&&(!Lock_Flag))
 154   1             {
 155   2                    if(SendBackData != OpenData)
 156   2                    {
 157   3                           SendBackData = OpenData;
 158   3                    }
 159   2             }
 160   1             else if((GetValue == MSG_KEY4_PRESS)&&(!Lock_Flag))
 161   1             {
 162   2                    if(SendBackData != CloseData)
 163   2                    {
 164   3                           SendBackData = CloseData;
 165   3                    }
 166   2             }
 167   1             else if((GetValue == MSG_KEY5_PRESS)&&(!Lock_Flag))
 168   1             {
C51 COMPILER V9.59.0.0   BSP_KEY                                                           04/16/2019 15:00:56 PAGE 4   

 169   2                    if(SendBackData != HeadUpData)
 170   2                    {
 171   3                           SendBackData = HeadUpData;
 172   3                    }
 173   2             }
 174   1             else if((GetValue == MSG_KEY6_PRESS)&&(!Lock_Flag))
 175   1             {
 176   2                    if(SendBackData != HeadDownData)
 177   2                    {
 178   3                           SendBackData = HeadDownData;
 179   3                    }
 180   2             }
 181   1             else if((GetValue == MSG_KEY7_PRESS)&&(!Lock_Flag))
 182   1             {
 183   2                    if(SendBackData != LumbarOpenData)
 184   2                    {
 185   3                           SendBackData = LumbarOpenData;
 186   3                    }
 187   2             }
 188   1             else if((GetValue == MSG_KEY8_PRESS)&&(!Lock_Flag))
 189   1             {
 190   2                    if(SendBackData != LumbarCloseData)
 191   2                    {
 192   3                           SendBackData = LumbarCloseData;
 193   3                    }
 194   2             }
 195   1             else if((GetValue == MSG_KEY9_PRESS)&&(!Lock_Flag))
 196   1             {
 197   2                     if(SendBackData != TableOpenData)
 198   2                    {
 199   3                           SendBackData = TableOpenData;
 200   3                    }
 201   2             }
 202   1             else if((GetValue == MSG_KEY10_PRESS)&&(!Lock_Flag))
 203   1             {
 204   2                   if(SendBackData != TableCloseData)
 205   2                    {
 206   3                           SendBackData = TableCloseData;
 207   3                    }
 208   2             }
 209   1             else if((GetValue == MSG_KEY2_LONGPRESS_HD)&&(!Lock_Flag))
 210   1             {
 211   2                    if(SendBackData != HomeData)
 212   2                   {
 213   3                           SendBackData = HomeData;
 214   3                    }
 215   2             }
 216   1             else if(GetValue == MSG_KEY1_LONGPRESS_HD)
 217   1             {
 218   2                    #if 0
                            if(SendBackData != LockData)
                            {
                                   SendBackData = LockData;
                                   ++ LockCnts;
                                   Lock_Handle();
                                   if(LockCnts & 0x01)
                                   {
                                          Pwm_Level = 0
                                   }
                                   else
                                   {
                                          
C51 COMPILER V9.59.0.0   BSP_KEY                                                           04/16/2019 15:00:56 PAGE 5   

                                   }
                            }
                            #else
 234   2                    if(!LockFlag)
 235   2                    {
 236   3                          LockFlag = 1;
 237   3                           ++ LockCnts;
 238   3                           Lock_Handle();
 239   3                           if(LockCnts & 0x01)
 240   3                           {
 241   4                                  Pwm_Level = 0;
 242   4                           }
 243   3                           else
 244   3                           {
 245   4                                  if(SendBackData == Led1_OpenData)
 246   4                                  {
 247   5                                         Pwm_Level = 100;
 248   5                                  }
 249   4                                  else if(SendBackData == Led1_CloseData)
 250   4                                  {
 251   5                                         Pwm_Level = 15;
 252   5                                  }
 253   4                           }
 254   3                    }
 255   2      
 256   2                    #endif
 257   2             }
 258   1      }
 259          /**
 260                 @function:°´¼üµÄÉ¨Ãè
 261                 @return :t_KEY_MSG ÀàÐÍµÄÏûÏ¢£¬ÏûÏ¢¼¯ÔÚt_KEY_MSGÖÐ¶¨Òå
 262          */
 263          t_KEY_MSG Key_Scan(void){
 264   1             unsigned char KeyIndex;
 265   1             if(SOCAPI_TouchKeyStatus&0x80) // ÖØÒª²½Öè 2: ´¥Ãþ¼üÉ¨ÃèÒ»ÂÖ±êÖ¾£¬ÊÇ·ñµ÷ÓÃ TouchKeyScan() Ò»¶¨Òª¸ù¾Ý´Ë±êÖ
             -¾Î»ÖÃÆðºó
 266   1             {
 267   2                    SOCAPI_TouchKeyStatus &= 0x7f;// ÖØÒª²½Öè 3:  Çå³ý±êÖ¾Î»£¬ ÐèÒªÍâ²¿Çå³ý¡£
 268   2                    get_key_data = TouchKeyScan();// °´¼üÊý¾Ý´¦Àíº¯Êý
 269   2                    TouchKeyRestart();// Æô¶¯ÏÂÒ»ÂÖ×ª»»
 270   2             }
 271   1             
 272   1             if(!(TimeOutDet_Check(&Key_Scan_Timer))){
 273   2                    return MSG_INVALID;
 274   2             }
 275   1             
 276   1             TimeOut_Record(&Key_Scan_Timer,KEY_SCAN_TIME);
 277   1             
 278   1             KeyIndex=GetKeyIndex();
 279   1             if(KeyIndex == MSG_INVALID)
 280   1                    return MSG_INVALID;
 281   1      
 282   1             switch(KeyState){
 283   2                    case KEY_STATE_IDLE:{
 284   3                           if(!KeyIndex){
 285   4                                  return MSG_KEY_NONE;
 286   4                           }
 287   3                           PreKeyIndex = KeyIndex;
 288   3                           TimeOut_Record(&Key_Wait_Timer,KEY_JITTER_TIME);
 289   3                           KeyState = KEY_STATE_JITTER;
 290   3                           break;
 291   3                    }
C51 COMPILER V9.59.0.0   BSP_KEY                                                           04/16/2019 15:00:56 PAGE 6   

 292   2                    
 293   2                    case KEY_STATE_JITTER:{
 294   3                           if(PreKeyIndex != KeyIndex){
 295   4                                  KeyState = KEY_STATE_IDLE;
 296   4                           }else if(TimeOutDet_Check(&Key_Wait_Timer)){
 297   4                                  TimeOut_Record(&Key_Wait_Timer,KEY_CP_TIME);
 298   4                                  KeyState = KEY_STATE_PRESS_DOWN;
 299   4                                  return KeyEvent[PreKeyIndex][0];
 300   4                           }
 301   3                           break;
 302   3                    }
 303   2      
 304   2                    case KEY_STATE_PRESS_DOWN:{
 305   3                           if(PreKeyIndex != KeyIndex){
 306   4                                  KeyState = KEY_STATE_IDLE;
 307   4                                  return KeyEvent[PreKeyIndex][1];
 308   4                           }else if(TimeOutDet_Check(&Key_Wait_Timer)){
 309   4                                  TimeOut_Record(&Key_Wait_Timer,KEY_CPH_TIME);
 310   4                                  KeyState = KEY_STATE_CP;
 311   4                                  return KeyEvent[PreKeyIndex][2];
 312   4                           }
 313   3                           break;
 314   3                    }
 315   2                    
 316   2                    case KEY_STATE_CP:{
 317   3                           if(PreKeyIndex != KeyIndex){
 318   4                                  KeyState = KEY_STATE_IDLE;
 319   4                                  return KeyEvent[PreKeyIndex][4];
 320   4                           }else if(TimeOutDet_Check(&Key_Wait_Timer)){
 321   4                                  TimeOut_Record(&Key_Wait_Timer,KEY_CPH_TIME);
 322   4                                  return KeyEvent[PreKeyIndex][3];
 323   4                           }
 324   3                           break;
 325   3                    }
 326   2                    
 327   2                    default:{
 328   3                           KeyState = KEY_STATE_IDLE;
 329   3                           break;
 330   3                    }
 331   2             }
 332   1             return MSG_INVALID;
 333   1      }
 334          
 335          
 336          void Key_Register(void (*Cb)(unsigned char))
 337          {
 338   1             if(Cb)
 339   1             {
 340   2                    GetValueCb = Cb;
 341   2             }
 342   1      }
 343          
 344          void Key_Poll(void)
 345          {
 346   1             Key_Msg = Key_Scan();
 347   1             if(GetValueCb)
 348   1             {
 349   2                    GetValueCb(Key_Msg);
 350   2             }
 351   1      }
 352          

C51 COMPILER V9.59.0.0   BSP_KEY                                                           04/16/2019 15:00:56 PAGE 7   


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    918    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     55    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     31       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
