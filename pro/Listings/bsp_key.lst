C51 COMPILER V9.59.0.0   BSP_KEY                                                           04/11/2019 19:21:23 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE BSP_KEY
OBJECT MODULE PLACED IN .\Objects\bsp_key.obj
COMPILER INVOKED BY: E:\MDK\C51\BIN\C51.EXE ..\bsp\bsp_key.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\bsp;..\lib;..\user;..\Ti
                    -meOut) DEBUG OBJECTEXTEND PRINT(.\Listings\bsp_key.lst) TABS(7) OBJECT(.\Objects\bsp_key.obj)

line level    source

   1          #include "bsp_key.h"
   2          #include "TimeOut.h"
   3          #include "key_port.h"
   4          #include "bsp_pwm.h"
   5          #include "bsp_lock.h"
   6          
   7          
   8          
   9          typedef enum {
  10              KEY_STATE_IDLE,
  11              KEY_STATE_JITTER,
  12              KEY_STATE_PRESS_DOWN,
  13              KEY_STATE_CP
  14          } KEY_STATE;
  15          
  16          unsigned char SendBackData;
  17          unsigned long get_key_data;
  18          //KEY_MSG_STATUS KeyMsgStatus;
  19          
  20          static TIMEOUT_PARA Key_Scan_Timer,Key_Wait_Timer;
  21          static KEY_STATE     KeyState;
  22          static t_KEY_MSG Key_Msg;
  23          static unsigned char PreKeyIndex = MSG_INVALID;
  24          
  25          extern unsigned char Lock_Flag;
  26          
  27          static void (*GetValueCb)(unsigned char);
  28          
  29          
  30          /**
  31                 @function: °´¼üÊÂ¼þ£¬¸ü¶à°´¼üÊ±£¬¶ÔÓ¦Ôö¼Ó°´¼ü°´¼ü
  32                 
  33          */
  34          static xdata unsigned char KeyEvent[9][5]=
  35          {
  36                 //°´¼ü¿ªÊ¼(°´ÏÂ)                   ¶Ì°´                                                    ³¤°´                               ³¤°´±£³Ö                                         ³¤°´ËÉ¿ª
  37                 {MSG_KEY_NONE,                                   MSG_KEY_NONE,                                    MSG_KEY_NONE,               MSG_KEY_NONE,                                    MSG_KEY_NONE},                     // ¿Õ£¬ÎÞÓÃ
  38                 {MSG_KEY1_PRESS,                          MSG_KEY1_SHORT_PRESS,                            MSG_KEY1_LONGPRESS,  MSG_KEY1_LONGPRESS_HD,                           MSG_KEY1_LONGP
             -RESS_RE},              // key1
  39                 {MSG_KEY2_PRESS,                          MSG_KEY2_SHORT_PRESS,                            MSG_KEY2_LONGPRESS,  MSG_KEY2_LONGPRESS_HD,                           MSG_KEY2_LONGP
             -RESS_RE},              // key2
  40                 {MSG_KEY3_PRESS,                          MSG_KEY3_SHORT_PRESS,                            MSG_KEY3_LONGPRESS,  MSG_KEY3_LONGPRESS_HD,                           MSG_KEY3_LON
             -GPRESS_RE},       // key3       
  41                 {MSG_KEY4_PRESS,                          MSG_KEY4_SHORT_PRESS,                            MSG_KEY4_LONGPRESS,  MSG_KEY4_LONGPRESS_HD,                           MSG_KEY4_LON
             -GPRESS_RE},       // key4       
  42                 {MSG_KEY5_PRESS,                          MSG_KEY5_SHORT_PRESS,                            MSG_KEY5_LONGPRESS,  MSG_KEY5_LONGPRESS_HD,                           MSG_KEY5_LON
             -GPRESS_RE},       // key5
  43                 {MSG_KEY6_PRESS,                          MSG_KEY6_SHORT_PRESS,                            MSG_KEY6_LONGPRESS,  MSG_KEY6_LONGPRESS_HD,                           MSG_KEY6_LON
             -GPRESS_RE},       // key6
  44                 {MSG_KEY7_PRESS,                          MSG_KEY7_SHORT_PRESS,                            MSG_KEY7_LONGPRESS,  MSG_KEY7_LONGPRESS_HD,                           MSG_KEY7_LON
             -GPRESS_RE},       // key7
  45                 {MSG_KEY8_PRESS,                          MSG_KEY8_SHORT_PRESS,                            MSG_KEY8_LONGPRESS,  MSG_KEY8_LONGPRESS_HD,                           MSG_KE
             -Y8_LONGPRESS_RE},    // key7
  46          };
C51 COMPILER V9.59.0.0   BSP_KEY                                                           04/11/2019 19:21:23 PAGE 2   

  47          
  48          /**
  49                 @function:    »ñÈ¡°´¼üË÷ÒýÖµ
  50                 ¸ù¾Ý°´¼üµÄ¸öÊý£¬ÐèÒª×öÏàÓ¦µÄÐÞ¸Ä
  51          */
  52          static unsigned char GetKeyIndex(void)
  53          {
  54   1             extern unsigned long Key_Port_Read(unsigned char num);
  55   1             unsigned char value = 0,cnt = 0;
  56   1             if(Key_Port_Read(1))
  57   1                    cnt ++,value = 1;
  58   1             if(Key_Port_Read(2))
  59   1                    cnt ++,value = 2;
  60   1             if(Key_Port_Read(3))
  61   1                    cnt ++,value = 3;
  62   1             if(Key_Port_Read(4))
  63   1                    cnt ++,value = 4;
  64   1             if(Key_Port_Read(5))
  65   1                    cnt ++,value = 5;
  66   1             if(Key_Port_Read(6))
  67   1                    cnt ++,value = 6;
  68   1             if(Key_Port_Read(7))
  69   1                    cnt ++,value = 7;
  70   1             if(Key_Port_Read(8))
  71   1                    cnt ++,value = 8;
  72   1             if(cnt > 1)
  73   1                    value = MSG_INVALID;
  74   1             return value; 
  75   1      }
  76          
  77          
  78          void  Key_Init(void)
  79          {
  80   1             TouchKeyInit(); // ´¥¿Ø°´¼ü³õÊ¼»¯
  81   1             KeyState=KEY_STATE_IDLE;
  82   1             TimeOut_Record(&Key_Scan_Timer,0);
  83   1      }
  84          
  85          void Key_Function(unsigned char GetValue)
  86          {
  87   1             static unsigned char TempCnts;
  88   1             if(GetValue == MSG_KEY_NONE)
  89   1             {
  90   2                    if(SendBackData != NoData)
  91   2                    {
  92   3                           SendBackData = NoData;
  93   3                    }
  94   2             }
  95   1             else if((GetValue == MSG_KEY1_SHORT_PRESS)&&(!Lock_Flag))
  96   1             {
  97   2                    if(SendBackData != LightData)
  98   2                    {
  99   3                           SendBackData = LightData;
 100   3                           ++ TempCnts;
 101   3                           if(TempCnts & 0x01)
 102   3                           {
 103   4                                  Pwm15_Level();
 104   4                           }
 105   3                           else
 106   3                           {
 107   4                                  Pwm100_Level();
 108   4                           }
C51 COMPILER V9.59.0.0   BSP_KEY                                                           04/11/2019 19:21:23 PAGE 3   

 109   3                    }
 110   2             }
 111   1             else if((GetValue == MSG_KEY2_PRESS)&&(!Lock_Flag))
 112   1             {
 113   2                    if(SendBackData != CupData)
 114   2                    {
 115   3                           SendBackData = CupData;
 116   3                           Motro_Handle();
*** WARNING C206 IN LINE 116 OF ..\bsp\bsp_key.c: 'Motro_Handle': missing function-prototype
 117   3                    }
 118   2             }
 119   1             else if((GetValue == MSG_KEY3_PRESS)&&(!Lock_Flag))
 120   1             {
 121   2                    if(SendBackData != HomeData)
 122   2                   {
 123   3                           SendBackData = HomeData;
 124   3                    }
 125   2             }
 126   1             else if((GetValue == MSG_KEY4_PRESS)&&(!Lock_Flag))
 127   1             {
 128   2                    if(SendBackData != OpenData)
 129   2                    {
 130   3                           SendBackData = OpenData;
 131   3                    }
 132   2             }
 133   1             else if((GetValue == MSG_KEY5_PRESS)&&(!Lock_Flag))
 134   1             {
 135   2                    if(SendBackData != CloseData)
 136   2                    {
 137   3                           SendBackData = CloseData;
 138   3                    }
 139   2             }
 140   1             else if((GetValue == MSG_KEY6_PRESS)&&(!Lock_Flag))
 141   1             {
 142   2                    if(SendBackData != HeadUpData)
 143   2                    {
 144   3                           SendBackData = HeadUpData;
 145   3                    }
 146   2             }
 147   1             else if((GetValue == MSG_KEY7_PRESS)&&(!Lock_Flag))
 148   1             {
 149   2                    if(SendBackData != HeadDownData)
 150   2                    {
 151   3                           SendBackData = HeadDownData;
 152   3                    }
 153   2             }
 154   1             else if((GetValue == MSG_KEY8_SHORT_PRESS)&&(!Lock_Flag))
 155   1             {
 156   2                    if(SendBackData != LockData)
 157   2                    {
 158   3                           SendBackData = LockData;
 159   3                    }
 160   2             }
 161   1             else if((GetValue == MSG_KEY1_LONGPRESS_HD)&&(!Lock_Flag))
 162   1             {
 163   2                    if(SendBackData != 0x88)
 164   2                    {
 165   3                           SendBackData = 0x88;
 166   3                    }
 167   2             }
 168   1             else if(GetValue == MSG_KEY8_LONGPRESS_HD)
 169   1             {
C51 COMPILER V9.59.0.0   BSP_KEY                                                           04/11/2019 19:21:23 PAGE 4   

 170   2                    if(SendBackData != 0x99)
 171   2                    {
 172   3                           SendBackData = 0x99;
 173   3                           Lock_Handle();
 174   3                    }
 175   2             }
 176   1      }
 177          /**
 178                 @function:°´¼üµÄÉ¨Ãè
 179                 @return :t_KEY_MSG ÀàÐÍµÄÏûÏ¢£¬ÏûÏ¢¼¯ÔÚt_KEY_MSGÖÐ¶¨Òå
 180          */
 181          t_KEY_MSG Key_Scan(void){
 182   1             unsigned char KeyIndex;
 183   1             if(SOCAPI_TouchKeyStatus&0x80) // ÖØÒª²½Öè 2: ´¥Ãþ¼üÉ¨ÃèÒ»ÂÖ±êÖ¾£¬ÊÇ·ñµ÷ÓÃ TouchKeyScan() Ò»¶¨Òª¸ù¾Ý´Ë±êÖ
             -¾Î»ÖÃÆðºó
 184   1             {
 185   2                    SOCAPI_TouchKeyStatus &= 0x7f;// ÖØÒª²½Öè 3:  Çå³ý±êÖ¾Î»£¬ ÐèÒªÍâ²¿Çå³ý¡£
 186   2                    get_key_data = TouchKeyScan();// °´¼üÊý¾Ý´¦Àíº¯Êý
 187   2                    TouchKeyRestart();// Æô¶¯ÏÂÒ»ÂÖ×ª»»
 188   2             }
 189   1             
 190   1             if(!(TimeOutDet_Check(&Key_Scan_Timer))){
 191   2                    return MSG_INVALID;
 192   2             }
 193   1             
 194   1             TimeOut_Record(&Key_Scan_Timer,KEY_SCAN_TIME);
 195   1             
 196   1             KeyIndex=GetKeyIndex();
 197   1             if(KeyIndex == MSG_INVALID)
 198   1                    return MSG_INVALID;
 199   1      
 200   1             switch(KeyState){
 201   2                    case KEY_STATE_IDLE:{
 202   3                           if(!KeyIndex){
 203   4                                  return MSG_KEY_NONE;
 204   4                           }
 205   3                           PreKeyIndex = KeyIndex;
 206   3                           TimeOut_Record(&Key_Wait_Timer,KEY_JITTER_TIME);
 207   3                           KeyState = KEY_STATE_JITTER;
 208   3                           break;
 209   3                    }
 210   2                    
 211   2                    case KEY_STATE_JITTER:{
 212   3                           if(PreKeyIndex != KeyIndex){
 213   4                                  KeyState = KEY_STATE_IDLE;
 214   4                           }else if(TimeOutDet_Check(&Key_Wait_Timer)){
 215   4                                  TimeOut_Record(&Key_Wait_Timer,KEY_CP_TIME);
 216   4                                  KeyState = KEY_STATE_PRESS_DOWN;
 217   4                                  return KeyEvent[PreKeyIndex][0];
 218   4                           }
 219   3                           break;
 220   3                    }
 221   2      
 222   2                    case KEY_STATE_PRESS_DOWN:{
 223   3                           if(PreKeyIndex != KeyIndex){
 224   4                                  KeyState = KEY_STATE_IDLE;
 225   4                                  return KeyEvent[PreKeyIndex][1];
 226   4                           }else if(TimeOutDet_Check(&Key_Wait_Timer)){
 227   4                                  TimeOut_Record(&Key_Wait_Timer,KEY_CPH_TIME);
 228   4                                  KeyState = KEY_STATE_CP;
 229   4                                  return KeyEvent[PreKeyIndex][2];
 230   4                           }
C51 COMPILER V9.59.0.0   BSP_KEY                                                           04/11/2019 19:21:23 PAGE 5   

 231   3                           break;
 232   3                    }
 233   2                    
 234   2                    case KEY_STATE_CP:{
 235   3                           if(PreKeyIndex != KeyIndex){
 236   4                                  KeyState = KEY_STATE_IDLE;
 237   4                                  return KeyEvent[PreKeyIndex][4];
 238   4                           }else if(TimeOutDet_Check(&Key_Wait_Timer)){
 239   4                                  TimeOut_Record(&Key_Wait_Timer,KEY_CPH_TIME);
 240   4                                  return KeyEvent[PreKeyIndex][3];
 241   4                           }
 242   3                           break;
 243   3                    }
 244   2                    
 245   2                    default:{
 246   3                           KeyState = KEY_STATE_IDLE;
 247   3                           break;
 248   3                    }
 249   2             }
 250   1             return MSG_INVALID;
 251   1      }
 252          
 253          
 254          void Key_Register(void (*Cb)(unsigned char))
 255          {
 256   1             if(Cb)
 257   1             {
 258   2                    GetValueCb = Cb;
 259   2             }
 260   1      }
 261          
 262          void Key_Poll(void)
 263          {
 264   1             Key_Msg = Key_Scan();
 265   1             if(GetValueCb)
 266   1             {
 267   2                    GetValueCb(Key_Msg);
 268   2             }
 269   1      }
 270          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    798    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     45    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     28       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
