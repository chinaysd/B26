C51 COMPILER V9.59.0.0   BSP_KEY                                                           04/17/2019 20:10:56 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE BSP_KEY
OBJECT MODULE PLACED IN .\Objects\bsp_key.obj
COMPILER INVOKED BY: E:\MDK\C51\BIN\C51.EXE ..\bsp\bsp_key.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\bsp;..\lib;..\user;..\Ti
                    -meOut) DEBUG OBJECTEXTEND PRINT(.\Listings\bsp_key.lst) TABS(7) OBJECT(.\Objects\bsp_key.obj)

line level    source

   1          #include "bsp_key.h"
   2          #include "TimeOut.h"
   3          #include "key_port.h"
   4          #include "bsp_pwm.h"
   5          #include "bsp_lock.h"
   6          #include "bsp_motro.h"
   7          
   8          
   9          
  10          
  11          typedef enum {
  12              KEY_STATE_IDLE,
  13              KEY_STATE_JITTER,
  14              KEY_STATE_PRESS_DOWN,
  15              KEY_STATE_CP
  16          } KEY_STATE;
  17          
  18          unsigned char SendBackData;
  19          unsigned long get_key_data;
  20          
  21          unsigned char LedOnlyOneInputFlag;
  22          //KEY_MSG_STATUS KeyMsgStatus;
  23          
  24          static TIMEOUT_PARA Key_Scan_Timer,Key_Wait_Timer;
  25          static KEY_STATE     KeyState;
  26          static t_KEY_MSG Key_Msg;
  27          static unsigned char PreKeyIndex = MSG_INVALID;
  28          
  29          extern unsigned char Lock_Flag;
  30          extern unsigned char Pwm_Level;
  31          
  32          static void (*GetValueCb)(unsigned char);
  33          
  34          
  35          /**
  36                 @function: °´¼üÊÂ¼þ£¬¸ü¶à°´¼üÊ±£¬¶ÔÓ¦Ôö¼Ó°´¼ü°´¼ü
  37                 
  38          */
  39          static xdata unsigned char KeyEvent[11][5]=
  40          {
  41                 //°´¼ü¿ªÊ¼(°´ÏÂ)                   ¶Ì°´                                                    ³¤°´                               ³¤°´±£³Ö                                         ³¤°´ËÉ¿ª
  42                 {MSG_KEY_NONE,                                   MSG_KEY_NONE,                                    MSG_KEY_NONE,               MSG_KEY_NONE,                                    MSG_KEY_NONE},                     // ¿Õ£¬ÎÞÓÃ
  43                 {MSG_KEY1_PRESS,                          MSG_KEY1_SHORT_PRESS,                            MSG_KEY1_LONGPRESS,  MSG_KEY1_LONGPRESS_HD,                           MSG_KEY1_LONGP
             -RESS_RE},              // key1
  44                 {MSG_KEY2_PRESS,                          MSG_KEY2_SHORT_PRESS,                            MSG_KEY2_LONGPRESS,  MSG_KEY2_LONGPRESS_HD,                           MSG_KEY2_LONGP
             -RESS_RE},              // key2
  45                 {MSG_KEY3_PRESS,                          MSG_KEY3_SHORT_PRESS,                            MSG_KEY3_LONGPRESS,  MSG_KEY3_LONGPRESS_HD,                           MSG_KEY3_LON
             -GPRESS_RE},       // key3       
  46                 {MSG_KEY4_PRESS,                          MSG_KEY4_SHORT_PRESS,                            MSG_KEY4_LONGPRESS,  MSG_KEY4_LONGPRESS_HD,                           MSG_KEY4_LON
             -GPRESS_RE},       // key4       
  47                 {MSG_KEY5_PRESS,                          MSG_KEY5_SHORT_PRESS,                            MSG_KEY5_LONGPRESS,  MSG_KEY5_LONGPRESS_HD,                           MSG_KEY5_LON
             -GPRESS_RE},       // key5
  48                 {MSG_KEY6_PRESS,                          MSG_KEY6_SHORT_PRESS,                            MSG_KEY6_LONGPRESS,  MSG_KEY6_LONGPRESS_HD,                           MSG_KEY6_LON
             -GPRESS_RE},       // key6
C51 COMPILER V9.59.0.0   BSP_KEY                                                           04/17/2019 20:10:56 PAGE 2   

  49                 {MSG_KEY7_PRESS,                          MSG_KEY7_SHORT_PRESS,                            MSG_KEY7_LONGPRESS,  MSG_KEY7_LONGPRESS_HD,                           MSG_KEY7_LON
             -GPRESS_RE},       // key7
  50                 {MSG_KEY8_PRESS,                          MSG_KEY8_SHORT_PRESS,                            MSG_KEY8_LONGPRESS,  MSG_KEY8_LONGPRESS_HD,                           MSG_KE
             -Y8_LONGPRESS_RE},    // key8
  51                 {MSG_KEY9_PRESS,                          MSG_KEY9_SHORT_PRESS,                            MSG_KEY9_LONGPRESS,   MSG_KEY9_LONGPRESS_HD,                   MSG_KEY
             -9_LONGPRESS_RE},     // key9
  52                 {MSG_KEY10_PRESS,                         MSG_KEY10_SHORT_PRESS,                           MSG_KEY10_LONGPRESS,  MSG_KEY10_LONGPRESS_HD,                  MSG
             -_KEY10_LONGPRESS_RE}, // key7
  53          };
  54          
  55          /**
  56                 @function:    »ñÈ¡°´¼üË÷ÒýÖµ
  57                 ¸ù¾Ý°´¼üµÄ¸öÊý£¬ÐèÒª×öÏàÓ¦µÄÐÞ¸Ä
  58          */
  59          static unsigned char GetKeyIndex(void)
  60          {
  61   1             extern unsigned long Key_Port_Read(unsigned char num);
  62   1             unsigned char value = 0,cnt = 0;
  63   1             if(Key_Port_Read(1))
  64   1                    cnt ++,value = 1;
  65   1             if(Key_Port_Read(2))
  66   1                    cnt ++,value = 2;
  67   1             if(Key_Port_Read(3))
  68   1                    cnt ++,value = 3;
  69   1             if(Key_Port_Read(4))
  70   1                    cnt ++,value = 4;
  71   1             if(Key_Port_Read(5))
  72   1                    cnt ++,value = 5;
  73   1             if(Key_Port_Read(6))
  74   1                    cnt ++,value = 6;
  75   1             if(Key_Port_Read(7))
  76   1                    cnt ++,value = 7;
  77   1             if(Key_Port_Read(8))
  78   1                    cnt ++,value = 8;
  79   1             if(Key_Port_Read(9))
  80   1                    cnt ++,value = 9;
  81   1             if(Key_Port_Read(10))
  82   1                    cnt ++,value = 10;
  83   1             if(cnt > 1)
  84   1                    value = MSG_INVALID;
  85   1             return value; 
  86   1      }
  87          
  88          
  89          void  Key_Init(void)
  90          {
  91   1             TouchKeyInit(); // ´¥¿Ø°´¼ü³õÊ¼»¯
  92   1             KeyState=KEY_STATE_IDLE;
  93   1             TimeOut_Record(&Key_Scan_Timer,0);
  94   1      }
  95          
  96          void Key_Function(unsigned char GetValue)
  97          {
  98   1             static unsigned char TempCnts,LockFlag;
  99   1             if(GetValue == MSG_KEY_NONE)
 100   1             {
 101   2                    if((SendBackData == Led1_OpenData)||(SendBackData == Led1_CloseData))
 102   2                    {
 103   3                           LedOnlyOneInputFlag = 0;
 104   3                    }
 105   2                    else
 106   2                    {
C51 COMPILER V9.59.0.0   BSP_KEY                                                           04/17/2019 20:10:56 PAGE 3   

 107   3                           if(SendBackData != NoData)
 108   3                           {
 109   4                                  SendBackData = NoData;
 110   4                           }
 111   3                    }
 112   2                    LockFlag = 0;
 113   2             }
 114   1             else if((GetValue == MSG_KEY1_PRESS)&&(!Lock_Flag))
 115   1             {
 116   2                    if(!LedOnlyOneInputFlag)
 117   2                    {
 118   3                           LedOnlyOneInputFlag = 1;
 119   3                           ++ TempCnts;
 120   3                           if(TempCnts & 0x01)
 121   3                           {
 122   4                                  SendBackData = Led1_OpenData;
 123   4                                  Pwm100_Level();
 124   4                           }
 125   3                           else
 126   3                           {
 127   4                                  SendBackData = Led1_CloseData;
 128   4                                  Pwm15_Level();
 129   4                           }
 130   3                     }
 131   2             }
 132   1             else if((GetValue == MSG_KEY2_PRESS)&&(!Lock_Flag))
 133   1             {
 134   2                    Motro_Handle();
 135   2             }
 136   1             else if((GetValue == MSG_KEY3_PRESS)&&(!Lock_Flag))
 137   1             {
 138   2                    if(SendBackData != HomeData)
 139   2                   {
 140   3                           SendBackData = HomeData;
 141   3                    }
 142   2             }
 143   1             else if((GetValue == MSG_KEY4_PRESS)&&(!Lock_Flag))
 144   1             {
 145   2                    if(SendBackData != OpenData)
 146   2                    {
 147   3                           SendBackData = OpenData;
 148   3                    }
 149   2             }
 150   1             else if((GetValue == MSG_KEY5_PRESS)&&(!Lock_Flag))
 151   1             {
 152   2                    if(SendBackData != CloseData)
 153   2                    {
 154   3                           SendBackData = CloseData;
 155   3                    }
 156   2             }
 157   1             else if((GetValue == MSG_KEY6_PRESS)&&(!Lock_Flag))
 158   1             {
 159   2                    if(SendBackData != HeadUpData)
 160   2                    {
 161   3                           SendBackData = HeadUpData;
 162   3                    }
 163   2             }
 164   1             else if((GetValue == MSG_KEY7_PRESS)&&(!Lock_Flag))
 165   1             {
 166   2                    if(SendBackData != HeadDownData)
 167   2                    {
 168   3                           SendBackData = HeadDownData;
C51 COMPILER V9.59.0.0   BSP_KEY                                                           04/17/2019 20:10:56 PAGE 4   

 169   3                    }
 170   2             }
 171   1             else if(GetValue == MSG_KEY10_LONGPRESS_HD)
 172   1             {
 173   2                  if(!LockFlag)
 174   2                    {
 175   3                          LockFlag = 1;
 176   3                           Lock_Handle();
 177   3                    }
 178   2             }
 179   1      }
 180          /**
 181                 @function:°´¼üµÄÉ¨Ãè
 182                 @return :t_KEY_MSG ÀàÐÍµÄÏûÏ¢£¬ÏûÏ¢¼¯ÔÚt_KEY_MSGÖÐ¶¨Òå
 183          */
 184          t_KEY_MSG Key_Scan(void){
 185   1             unsigned char KeyIndex;
 186   1             if(SOCAPI_TouchKeyStatus&0x80) // ÖØÒª²½Öè 2: ´¥Ãþ¼üÉ¨ÃèÒ»ÂÖ±êÖ¾£¬ÊÇ·ñµ÷ÓÃ TouchKeyScan() Ò»¶¨Òª¸ù¾Ý´Ë±êÖ
             -¾Î»ÖÃÆðºó
 187   1             {
 188   2                    SOCAPI_TouchKeyStatus &= 0x7f;// ÖØÒª²½Öè 3:  Çå³ý±êÖ¾Î»£¬ ÐèÒªÍâ²¿Çå³ý¡£
 189   2                    get_key_data = TouchKeyScan();// °´¼üÊý¾Ý´¦Àíº¯Êý
 190   2                    TouchKeyRestart();// Æô¶¯ÏÂÒ»ÂÖ×ª»»
 191   2             }
 192   1             
 193   1             if(!(TimeOutDet_Check(&Key_Scan_Timer))){
 194   2                    return MSG_INVALID;
 195   2             }
 196   1             
 197   1             TimeOut_Record(&Key_Scan_Timer,KEY_SCAN_TIME);
 198   1             
 199   1             KeyIndex=GetKeyIndex();
 200   1             if(KeyIndex == MSG_INVALID)
 201   1                    return MSG_INVALID;
 202   1      
 203   1             switch(KeyState){
 204   2                    case KEY_STATE_IDLE:{
 205   3                           if(!KeyIndex){
 206   4                                  return MSG_KEY_NONE;
 207   4                           }
 208   3                           PreKeyIndex = KeyIndex;
 209   3                           TimeOut_Record(&Key_Wait_Timer,KEY_JITTER_TIME);
 210   3                           KeyState = KEY_STATE_JITTER;
 211   3                           break;
 212   3                    }
 213   2                    
 214   2                    case KEY_STATE_JITTER:{
 215   3                           if(PreKeyIndex != KeyIndex){
 216   4                                  KeyState = KEY_STATE_IDLE;
 217   4                           }else if(TimeOutDet_Check(&Key_Wait_Timer)){
 218   4                                  TimeOut_Record(&Key_Wait_Timer,KEY_CP_TIME);
 219   4                                  KeyState = KEY_STATE_PRESS_DOWN;
 220   4                                  return KeyEvent[PreKeyIndex][0];
 221   4                           }
 222   3                           break;
 223   3                    }
 224   2      
 225   2                    case KEY_STATE_PRESS_DOWN:{
 226   3                           if(PreKeyIndex != KeyIndex){
 227   4                                  KeyState = KEY_STATE_IDLE;
 228   4                                  return KeyEvent[PreKeyIndex][1];
 229   4                           }else if(TimeOutDet_Check(&Key_Wait_Timer)){
C51 COMPILER V9.59.0.0   BSP_KEY                                                           04/17/2019 20:10:56 PAGE 5   

 230   4                                  TimeOut_Record(&Key_Wait_Timer,KEY_CPH_TIME);
 231   4                                  KeyState = KEY_STATE_CP;
 232   4                                  return KeyEvent[PreKeyIndex][2];
 233   4                           }
 234   3                           break;
 235   3                    }
 236   2                    
 237   2                    case KEY_STATE_CP:{
 238   3                           if(PreKeyIndex != KeyIndex){
 239   4                                  KeyState = KEY_STATE_IDLE;
 240   4                                  return KeyEvent[PreKeyIndex][4];
 241   4                           }else if(TimeOutDet_Check(&Key_Wait_Timer)){
 242   4                                  TimeOut_Record(&Key_Wait_Timer,KEY_CPH_TIME);
 243   4                                  return KeyEvent[PreKeyIndex][3];
 244   4                           }
 245   3                           break;
 246   3                    }
 247   2                    
 248   2                    default:{
 249   3                           KeyState = KEY_STATE_IDLE;
 250   3                           break;
 251   3                    }
 252   2             }
 253   1             return MSG_INVALID;
 254   1      }
 255          
 256          
 257          void Key_Register(void (*Cb)(unsigned char))
 258          {
 259   1             if(Cb)
 260   1             {
 261   2                    GetValueCb = Cb;
 262   2             }
 263   1      }
 264          
 265          void Key_Poll(void)
 266          {
 267   1             Key_Msg = Key_Scan();
 268   1             if(GetValueCb)
 269   1             {
 270   2                    GetValueCb(Key_Msg);
 271   2             }
 272   1      }
 273          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    787    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     55    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     30       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
