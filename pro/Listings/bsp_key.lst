C51 COMPILER V9.59.0.0   BSP_KEY                                                           04/15/2019 11:37:19 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE BSP_KEY
OBJECT MODULE PLACED IN .\Objects\bsp_key.obj
COMPILER INVOKED BY: E:\MDK\C51\BIN\C51.EXE ..\bsp\bsp_key.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\bsp;..\lib;..\user;..\Ti
                    -meOut) DEBUG OBJECTEXTEND PRINT(.\Listings\bsp_key.lst) TABS(7) OBJECT(.\Objects\bsp_key.obj)

line level    source

   1          #include "bsp_key.h"
   2          #include "TimeOut.h"
   3          #include "key_port.h"
   4          #include "bsp_pwm.h"
   5          #include "bsp_lock.h"
   6          #include "bsp_motro.h"
   7          
   8          
   9          
  10          
  11          typedef enum {
  12              KEY_STATE_IDLE,
  13              KEY_STATE_JITTER,
  14              KEY_STATE_PRESS_DOWN,
  15              KEY_STATE_CP
  16          } KEY_STATE;
  17          
  18          unsigned char SendBackData;
  19          unsigned long get_key_data;
  20          //KEY_MSG_STATUS KeyMsgStatus;
  21          
  22          static TIMEOUT_PARA Key_Scan_Timer,Key_Wait_Timer;
  23          static KEY_STATE     KeyState;
  24          static t_KEY_MSG Key_Msg;
  25          static unsigned char PreKeyIndex = MSG_INVALID;
  26          
  27          extern unsigned char Lock_Flag;
  28          
  29          static void (*GetValueCb)(unsigned char);
  30          
  31          
  32          /**
  33                 @function: °´¼üÊÂ¼þ£¬¸ü¶à°´¼üÊ±£¬¶ÔÓ¦Ôö¼Ó°´¼ü°´¼ü
  34                 
  35          */
  36          static xdata unsigned char KeyEvent[11][5]=
  37          {
  38                 //°´¼ü¿ªÊ¼(°´ÏÂ)                   ¶Ì°´                                                    ³¤°´                               ³¤°´±£³Ö                                         ³¤°´ËÉ¿ª
  39                 {MSG_KEY_NONE,                                   MSG_KEY_NONE,                                    MSG_KEY_NONE,               MSG_KEY_NONE,                                    MSG_KEY_NONE},                     // ¿Õ£¬ÎÞÓÃ
  40                 {MSG_KEY1_PRESS,                          MSG_KEY1_SHORT_PRESS,                            MSG_KEY1_LONGPRESS,  MSG_KEY1_LONGPRESS_HD,                           MSG_KEY1_LONGP
             -RESS_RE},              // key1
  41                 {MSG_KEY2_PRESS,                          MSG_KEY2_SHORT_PRESS,                            MSG_KEY2_LONGPRESS,  MSG_KEY2_LONGPRESS_HD,                           MSG_KEY2_LONGP
             -RESS_RE},              // key2
  42                 {MSG_KEY3_PRESS,                          MSG_KEY3_SHORT_PRESS,                            MSG_KEY3_LONGPRESS,  MSG_KEY3_LONGPRESS_HD,                           MSG_KEY3_LON
             -GPRESS_RE},       // key3       
  43                 {MSG_KEY4_PRESS,                          MSG_KEY4_SHORT_PRESS,                            MSG_KEY4_LONGPRESS,  MSG_KEY4_LONGPRESS_HD,                           MSG_KEY4_LON
             -GPRESS_RE},       // key4       
  44                 {MSG_KEY5_PRESS,                          MSG_KEY5_SHORT_PRESS,                            MSG_KEY5_LONGPRESS,  MSG_KEY5_LONGPRESS_HD,                           MSG_KEY5_LON
             -GPRESS_RE},       // key5
  45                 {MSG_KEY6_PRESS,                          MSG_KEY6_SHORT_PRESS,                            MSG_KEY6_LONGPRESS,  MSG_KEY6_LONGPRESS_HD,                           MSG_KEY6_LON
             -GPRESS_RE},       // key6
  46                 {MSG_KEY7_PRESS,                          MSG_KEY7_SHORT_PRESS,                            MSG_KEY7_LONGPRESS,  MSG_KEY7_LONGPRESS_HD,                           MSG_KEY7_LON
             -GPRESS_RE},       // key7
  47                 {MSG_KEY8_PRESS,                          MSG_KEY8_SHORT_PRESS,                            MSG_KEY8_LONGPRESS,  MSG_KEY8_LONGPRESS_HD,                           MSG_KE
C51 COMPILER V9.59.0.0   BSP_KEY                                                           04/15/2019 11:37:19 PAGE 2   

             -Y8_LONGPRESS_RE},    // key8
  48                 {MSG_KEY9_PRESS,                          MSG_KEY9_SHORT_PRESS,                            MSG_KEY9_LONGPRESS,   MSG_KEY9_LONGPRESS_HD,                   MSG_KEY
             -9_LONGPRESS_RE},     // key9
  49                 {MSG_KEY10_PRESS,                         MSG_KEY10_SHORT_PRESS,                           MSG_KEY10_LONGPRESS,  MSG_KEY10_LONGPRESS_HD,                  MSG
             -_KEY10_LONGPRESS_RE}, // key7
  50          };
  51          
  52          /**
  53                 @function:    »ñÈ¡°´¼üË÷ÒýÖµ
  54                 ¸ù¾Ý°´¼üµÄ¸öÊý£¬ÐèÒª×öÏàÓ¦µÄÐÞ¸Ä
  55          */
  56          static unsigned char GetKeyIndex(void)
  57          {
  58   1             extern unsigned long Key_Port_Read(unsigned char num);
  59   1             unsigned char value = 0,cnt = 0;
  60   1             if(Key_Port_Read(1))
  61   1                    cnt ++,value = 1;
  62   1             if(Key_Port_Read(2))
  63   1                    cnt ++,value = 2;
  64   1             if(Key_Port_Read(3))
  65   1                    cnt ++,value = 3;
  66   1             if(Key_Port_Read(4))
  67   1                    cnt ++,value = 4;
  68   1             if(Key_Port_Read(5))
  69   1                    cnt ++,value = 5;
  70   1             if(Key_Port_Read(6))
  71   1                    cnt ++,value = 6;
  72   1             if(Key_Port_Read(7))
  73   1                    cnt ++,value = 7;
  74   1             if(Key_Port_Read(8))
  75   1                    cnt ++,value = 8;
  76   1             if(Key_Port_Read(9))
  77   1                    cnt ++,value = 9;
  78   1             if(Key_Port_Read(10))
  79   1                    cnt ++,value = 10;
  80   1             if(cnt > 1)
  81   1                    value = MSG_INVALID;
  82   1             return value; 
  83   1      }
  84          
  85          
  86          void  Key_Init(void)
  87          {
  88   1             TouchKeyInit(); // ´¥¿Ø°´¼ü³õÊ¼»¯
  89   1             KeyState=KEY_STATE_IDLE;
  90   1             TimeOut_Record(&Key_Scan_Timer,0);
  91   1      }
  92          
  93          void Key_Function(unsigned char GetValue)
  94          {
  95   1             static unsigned char TempCnts;
  96   1             if(GetValue == MSG_KEY_NONE)
  97   1             {
  98   2                    if(SendBackData != NoData)
  99   2                    {
 100   3                           SendBackData = NoData;
 101   3                    }
 102   2             }
 103   1             else if((GetValue == MSG_KEY1_SHORT_PRESS)&&(!Lock_Flag))
 104   1             {
 105   2                    if((SendBackData != Led1_OpenData)||(SendBackData != Led1_CloseData))
 106   2                    {
C51 COMPILER V9.59.0.0   BSP_KEY                                                           04/15/2019 11:37:19 PAGE 3   

 107   3                           ++ TempCnts;
 108   3                           if(TempCnts & 0x01)
 109   3                           {
 110   4                                  SendBackData = Led1_OpenData;
 111   4                                  Pwm100_Level();
 112   4                           }
 113   3                           else
 114   3                           {
 115   4                                  SendBackData = Led1_CloseData;
 116   4                                  Pwm15_Level();
 117   4                           }
 118   3                    }
 119   2             }
 120   1             else if((GetValue == MSG_KEY2_SHORT_PRESS)&&(!Lock_Flag))
 121   1             {
 122   2                    Motro_Handle();
 123   2             }
 124   1             else if((GetValue == MSG_KEY3_PRESS)&&(!Lock_Flag))
 125   1             {
 126   2                    if(SendBackData != OpenData)
 127   2                    {
 128   3                           SendBackData = OpenData;
 129   3                    }
 130   2             }
 131   1             else if((GetValue == MSG_KEY4_PRESS)&&(!Lock_Flag))
 132   1             {
 133   2                    if(SendBackData != CloseData)
 134   2                    {
 135   3                           SendBackData = CloseData;
 136   3                    }
 137   2             }
 138   1             else if((GetValue == MSG_KEY5_PRESS)&&(!Lock_Flag))
 139   1             {
 140   2                    if(SendBackData != HeadUpData)
 141   2                    {
 142   3                           SendBackData = HeadUpData;
 143   3                    }
 144   2             }
 145   1             else if((GetValue == MSG_KEY6_PRESS)&&(!Lock_Flag))
 146   1             {
 147   2                    if(SendBackData != HeadDownData)
 148   2                    {
 149   3                           SendBackData = HeadDownData;
 150   3                    }
 151   2             }
 152   1             else if((GetValue == MSG_KEY7_PRESS)&&(!Lock_Flag))
 153   1             {
 154   2                    if(SendBackData != LumbarOpenData)
 155   2                    {
 156   3                           SendBackData = LumbarOpenData;
 157   3                    }
 158   2             }
 159   1             else if((GetValue == MSG_KEY8_PRESS)&&(!Lock_Flag))
 160   1             {
 161   2                    if(SendBackData != LumbarCloseData)
 162   2                    {
 163   3                           SendBackData = LumbarCloseData;
 164   3                    }
 165   2             }
 166   1             else if((GetValue == MSG_KEY9_PRESS)&&(!Lock_Flag))
 167   1             {
 168   2                     if(SendBackData != TableOpenData)
C51 COMPILER V9.59.0.0   BSP_KEY                                                           04/15/2019 11:37:19 PAGE 4   

 169   2                    {
 170   3                           SendBackData = TableOpenData;
 171   3                    }
 172   2             }
 173   1             else if((GetValue == MSG_KEY10_PRESS)&&(!Lock_Flag))
 174   1             {
 175   2                   if(SendBackData != TableCloseData)
 176   2                    {
 177   3                           SendBackData = TableCloseData;
 178   3                    }
 179   2             }
 180   1             else if((GetValue == MSG_KEY2_LONGPRESS_HD)&&(!Lock_Flag))
 181   1             {
 182   2                    if(SendBackData != HomeData)
 183   2                   {
 184   3                           SendBackData = HomeData;
 185   3                    }
 186   2             }
 187   1             else if(GetValue == MSG_KEY1_LONGPRESS_HD)
 188   1             {
 189   2                    if(SendBackData != LockData)
 190   2                    {
 191   3                           SendBackData = LockData;
 192   3                           Lock_Handle();
 193   3                    }
 194   2             }
 195   1      }
 196          /**
 197                 @function:°´¼üµÄÉ¨Ãè
 198                 @return :t_KEY_MSG ÀàÐÍµÄÏûÏ¢£¬ÏûÏ¢¼¯ÔÚt_KEY_MSGÖÐ¶¨Òå
 199          */
 200          t_KEY_MSG Key_Scan(void){
 201   1             unsigned char KeyIndex;
 202   1             if(SOCAPI_TouchKeyStatus&0x80) // ÖØÒª²½Öè 2: ´¥Ãþ¼üÉ¨ÃèÒ»ÂÖ±êÖ¾£¬ÊÇ·ñµ÷ÓÃ TouchKeyScan() Ò»¶¨Òª¸ù¾Ý´Ë±êÖ
             -¾Î»ÖÃÆðºó
 203   1             {
 204   2                    SOCAPI_TouchKeyStatus &= 0x7f;// ÖØÒª²½Öè 3:  Çå³ý±êÖ¾Î»£¬ ÐèÒªÍâ²¿Çå³ý¡£
 205   2                    get_key_data = TouchKeyScan();// °´¼üÊý¾Ý´¦Àíº¯Êý
 206   2                    TouchKeyRestart();// Æô¶¯ÏÂÒ»ÂÖ×ª»»
 207   2             }
 208   1             
 209   1             if(!(TimeOutDet_Check(&Key_Scan_Timer))){
 210   2                    return MSG_INVALID;
 211   2             }
 212   1             
 213   1             TimeOut_Record(&Key_Scan_Timer,KEY_SCAN_TIME);
 214   1             
 215   1             KeyIndex=GetKeyIndex();
 216   1             if(KeyIndex == MSG_INVALID)
 217   1                    return MSG_INVALID;
 218   1      
 219   1             switch(KeyState){
 220   2                    case KEY_STATE_IDLE:{
 221   3                           if(!KeyIndex){
 222   4                                  return MSG_KEY_NONE;
 223   4                           }
 224   3                           PreKeyIndex = KeyIndex;
 225   3                           TimeOut_Record(&Key_Wait_Timer,KEY_JITTER_TIME);
 226   3                           KeyState = KEY_STATE_JITTER;
 227   3                           break;
 228   3                    }
 229   2                    
C51 COMPILER V9.59.0.0   BSP_KEY                                                           04/15/2019 11:37:19 PAGE 5   

 230   2                    case KEY_STATE_JITTER:{
 231   3                           if(PreKeyIndex != KeyIndex){
 232   4                                  KeyState = KEY_STATE_IDLE;
 233   4                           }else if(TimeOutDet_Check(&Key_Wait_Timer)){
 234   4                                  TimeOut_Record(&Key_Wait_Timer,KEY_CP_TIME);
 235   4                                  KeyState = KEY_STATE_PRESS_DOWN;
 236   4                                  return KeyEvent[PreKeyIndex][0];
 237   4                           }
 238   3                           break;
 239   3                    }
 240   2      
 241   2                    case KEY_STATE_PRESS_DOWN:{
 242   3                           if(PreKeyIndex != KeyIndex){
 243   4                                  KeyState = KEY_STATE_IDLE;
 244   4                                  return KeyEvent[PreKeyIndex][1];
 245   4                           }else if(TimeOutDet_Check(&Key_Wait_Timer)){
 246   4                                  TimeOut_Record(&Key_Wait_Timer,KEY_CPH_TIME);
 247   4                                  KeyState = KEY_STATE_CP;
 248   4                                  return KeyEvent[PreKeyIndex][2];
 249   4                           }
 250   3                           break;
 251   3                    }
 252   2                    
 253   2                    case KEY_STATE_CP:{
 254   3                           if(PreKeyIndex != KeyIndex){
 255   4                                  KeyState = KEY_STATE_IDLE;
 256   4                                  return KeyEvent[PreKeyIndex][4];
 257   4                           }else if(TimeOutDet_Check(&Key_Wait_Timer)){
 258   4                                  TimeOut_Record(&Key_Wait_Timer,KEY_CPH_TIME);
 259   4                                  return KeyEvent[PreKeyIndex][3];
 260   4                           }
 261   3                           break;
 262   3                    }
 263   2                    
 264   2                    default:{
 265   3                           KeyState = KEY_STATE_IDLE;
 266   3                           break;
 267   3                    }
 268   2             }
 269   1             return MSG_INVALID;
 270   1      }
 271          
 272          
 273          void Key_Register(void (*Cb)(unsigned char))
 274          {
 275   1             if(Cb)
 276   1             {
 277   2                    GetValueCb = Cb;
 278   2             }
 279   1      }
 280          
 281          void Key_Poll(void)
 282          {
 283   1             Key_Msg = Key_Scan();
 284   1             if(GetValueCb)
 285   1             {
 286   2                    GetValueCb(Key_Msg);
 287   2             }
 288   1      }
 289          


C51 COMPILER V9.59.0.0   BSP_KEY                                                           04/15/2019 11:37:19 PAGE 6   

MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    871    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     55    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     28       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
